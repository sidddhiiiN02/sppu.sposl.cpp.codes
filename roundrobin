//Write a program to simulate CPU Scheduling Algorithm: Round Robin
(Preemptive).
Sample Input:
Time Quantum = 2
Process Arrival time Burst Time
P1 0 6
P2 1 4
P3 4 8
P4 3 3

#include <iostream>
#include <vector>
#include <iomanip>
#include <queue>

using namespace std;

struct Process {
    int pid;
    int at;
    int bt;
    int rt;
    int ct, tat, wt;
    bool in_queue;
};

int main() {
    int TQ = 2;
    vector<Process> p = {
        {1, 0, 6, 6, 0, 0, 0, false},
        {2, 1, 4, 4, 0, 0, 0, false},
        {3, 4, 8, 8, 0, 0, 0, false},
        {4, 3, 3, 3, 0, 0, 0, false}
    };
    int n = p.size();
    
    queue<int> ready_queue;
    int completed_count = 0;
    int current_time = 0;
    float total_tat = 0;
    float total_wt = 0;

    cout << "--- Round Robin (TQ=" << TQ << ") Scheduling ---" << endl;
    cout << "Gantt Chart (simplified): ";

    ready_queue.push(0);
    p[0].in_queue = true;

    while (completed_count != n) {
        
        if (ready_queue.empty()) {
            current_time++;
            for (int i = 0; i < n; i++) {
                if (p[i].rt > 0 && !p[i].in_queue && p[i].at <= current_time) {
                    ready_queue.push(i);
                    p[i].in_queue = true;
                }
            }
            cout << current_time -1 << " [IDLE] ";
            continue;
        }

        int i = ready_queue.front();
        ready_queue.pop();
        p[i].in_queue = false;

        cout << current_time << " [P" << p[i].pid << "] ";
        
        int time_slice = min(TQ, p[i].rt);
        p[i].rt -= time_slice;
        
        for(int t = 0; t < time_slice; t++) {
            current_time++;
            for (int j = 0; j < n; j++) {
                if (p[j].rt > 0 && !p[j].in_queue && p[j].at == current_time) {
                    ready_queue.push(j);
                    p[j].in_queue = true;
                }
            }
        }
        
        if (p[i].rt == 0) {
            completed_count++;
            p[i].ct = current_time;
            p[i].tat = p[i].ct - p[i].at;
            p[i].wt = p[i].tat - p[i].bt;
            total_tat += p[i].tat;
            total_wt += p[i].wt;
            cout << current_time << " | ";
        } else {
            ready_queue.push(i);
            p[i].in_queue = true;
        }
    }
    cout << endl << endl;

    cout << setfill(' ') << left;
    cout << setw(5) << "PID" << setw(5) << "AT" << setw(5) << "BT" 
         << setw(5) << "CT" << setw(5) << "TAT" << setw(5) << "WT" << endl;
    cout << "-------------------------------" << endl;

    for (int i = 0; i < n; i++) {
        cout << setw(5) << p[i].pid << setw(5) << p[i].at << setw(5) << p[i].bt
             << setw(5) << p[i].ct << setw(5) << p[i].tat << setw(5) << p[i].wt << endl;
    }

    cout << "\nAverage Turnaround Time: " << (total_tat / n) << endl;
    cout << "Average Waiting Time: " << (total_wt / n) << endl;

    return 0;
}
